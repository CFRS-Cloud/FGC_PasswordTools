package uk.org.cambsfire.security;

/*-
 * #%L
 * Password Tools
 * %%
 * Copyright (C) 2016 - 2017 Cambridgeshire Fire and Rescue Service
 * %%
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Cambridgeshire Fire and Rescue Service nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * #L%
 */


import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.util.Arrays;
import java.util.Random;

import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;

/**
 * Encodes and verifies passwords using the OWASP recommended method outlined at
 * https://www.owasp.org/index.php/Hashing_Java
 *
 *
 * @author david.bower
 *
 */
public final class PasswordEncoder {
    /**
     * Algorithm used by this password encoder. Expected to be available on any JVM since 1.4.
     */
    public static final String KEY_ALGORITHM = "PBKDF2WithHmacSHA512";

    /**
     * Salt length used by this encoder
     */
    private static final int SALT_LENGTH_BYTES = 64;

    /**
     * Minimum salt length that will be accepted when matching passwords
     */
    private static final int MIN_SALT_LENGTH = 32;

    /**
     * A 'secure' number of iterations
     */
    public static final int DEFAULT_ITERATIONS = 30000;
    /**
     * Minimum allowed iterations
     */
    public static final int MIN_ITERATIONS = 500;

    /**
     * Safe key length as advised by OWASP
     */
    private static final int DEFAULT_KEY_LENGTH = 256;

    private PasswordEncoder() {
        // Utility class
    }

    /**
     * Encode a password with {@link DEFAULT_ITERATIONS}
     *
     * @return The encoded password
     */
    public static String encode(final String rawPassword) {
        return encode(rawPassword, DEFAULT_ITERATIONS);
    }

    /**
     * Encode a password using {@link KEY_ALGORITHM} with the given number of iterations.
     * The number of iterations should be a balance between time to encode the password and the time taken to crack the
     * encoded password.
     *
     * @param iterations
     *            The number of hash iterations. Must be at least {@link MIN_ITERATIONS}
     * @param rawPassword
     *            a non-null non-empty password
     * @return The encoded password in the form <Base64 salt>.<Hex iterations>.<Base64 password hash>
     */
    public static String encode(final String rawPassword, final int iterations) {
        if (rawPassword.length() == 0) {
            throw new PasswordGenerationException("Password may not be empty");
        }
        if (iterations < MIN_ITERATIONS) {
            throw new PasswordGenerationException("Minimum number of iterations is " + MIN_ITERATIONS);
        }

        final byte[] salt = generateSalt();
        final byte[] passwordHash =
                hashPassword(rawPassword.toCharArray(), salt, iterations, DEFAULT_KEY_LENGTH);
        final EncodedPassword encodedPassword = new EncodedPassword(salt, iterations, passwordHash);
        return encodedPassword.asEncodedString();
    }

    /**
     * Test a password against a stored encoded hash.
     *
     * @param rawPassword
     *            a non-null non-empty password
     * @param An
     *            encoded password as generated by one of the encode(...) methods
     * @return true if the rawPassword matches the encoded password
     */
    public static boolean matches(final String rawPassword, final String encodedHashedPassword) {
        if (encodedHashedPassword == null || encodedHashedPassword.length() == 0) {
            return false;
        }
        try {
            final EncodedPassword encodedPassword = EncodedPassword.parse(encodedHashedPassword);
            if (!encodedPasswordIsValid(encodedPassword)) {
                return false;
            }

            final byte[] hashedPassword = hashPassword(rawPassword.toCharArray(),
                    encodedPassword.getSalt(),
                    encodedPassword.getNumIterations(),
                    DEFAULT_KEY_LENGTH);

            return Arrays.equals(encodedPassword.getPasswordHash(), hashedPassword);
        } catch (final EncodedPasswordException e) {
            return false;
        }
    }

    private static boolean encodedPasswordIsValid(final EncodedPassword encodedPassword) {
        return encodedPassword.getSalt().length >= MIN_SALT_LENGTH && encodedPassword.getNumIterations() > 0
                && encodedPassword.getPasswordHash().length > 0;
    }

    private static byte[] generateSalt() {
        final Random r = new SecureRandom();
        final byte[] salt = new byte[SALT_LENGTH_BYTES];
        r.nextBytes(salt);
        return salt;
    }

    private static byte[] hashPassword(final char[] password, final byte[] salt, final int iterations,
            final int keyLength) {
        try {
            final SecretKeyFactory skf = SecretKeyFactory.getInstance(KEY_ALGORITHM);
            final PBEKeySpec spec = new PBEKeySpec(password, salt, iterations, keyLength);
            final SecretKey key = skf.generateSecret(spec);
            final byte[] res = key.getEncoded();
            return res;

        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
            throw new PasswordGenerationException(e);
        }
    }
}
